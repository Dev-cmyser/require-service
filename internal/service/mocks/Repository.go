// Code generated by mockery v2.46.2. DO NOT EDIT.

package mocks

import (
	context "context"

	models "github.com/himmel520/uoffer/require/models"
	mock "github.com/stretchr/testify/mock"
)

// Repository is an autogenerated mock type for the Repository type
type Repository struct {
	mock.Mock
}

type Repository_Expecter struct {
	mock *mock.Mock
}

func (_m *Repository) EXPECT() *Repository_Expecter {
	return &Repository_Expecter{mock: &_m.Mock}
}

// AddAnalytic provides a mock function with given fields: ctx, analytic
func (_m *Repository) AddAnalytic(ctx context.Context, analytic *models.Analytic) (*models.Analytic, error) {
	ret := _m.Called(ctx, analytic)

	if len(ret) == 0 {
		panic("no return value specified for AddAnalytic")
	}

	var r0 *models.Analytic
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Analytic) (*models.Analytic, error)); ok {
		return rf(ctx, analytic)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.Analytic) *models.Analytic); ok {
		r0 = rf(ctx, analytic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Analytic)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.Analytic) error); ok {
		r1 = rf(ctx, analytic)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_AddAnalytic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddAnalytic'
type Repository_AddAnalytic_Call struct {
	*mock.Call
}

// AddAnalytic is a helper method to define mock.On call
//   - ctx context.Context
//   - analytic *models.Analytic
func (_e *Repository_Expecter) AddAnalytic(ctx interface{}, analytic interface{}) *Repository_AddAnalytic_Call {
	return &Repository_AddAnalytic_Call{Call: _e.mock.On("AddAnalytic", ctx, analytic)}
}

func (_c *Repository_AddAnalytic_Call) Run(run func(ctx context.Context, analytic *models.Analytic)) *Repository_AddAnalytic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Analytic))
	})
	return _c
}

func (_c *Repository_AddAnalytic_Call) Return(_a0 *models.Analytic, _a1 error) *Repository_AddAnalytic_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_AddAnalytic_Call) RunAndReturn(run func(context.Context, *models.Analytic) (*models.Analytic, error)) *Repository_AddAnalytic_Call {
	_c.Call.Return(run)
	return _c
}

// AddCategory provides a mock function with given fields: ctx, category
func (_m *Repository) AddCategory(ctx context.Context, category *models.Category) (*models.Category, error) {
	ret := _m.Called(ctx, category)

	if len(ret) == 0 {
		panic("no return value specified for AddCategory")
	}

	var r0 *models.Category
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Category) (*models.Category, error)); ok {
		return rf(ctx, category)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.Category) *models.Category); ok {
		r0 = rf(ctx, category)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Category)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.Category) error); ok {
		r1 = rf(ctx, category)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_AddCategory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCategory'
type Repository_AddCategory_Call struct {
	*mock.Call
}

// AddCategory is a helper method to define mock.On call
//   - ctx context.Context
//   - category *models.Category
func (_e *Repository_Expecter) AddCategory(ctx interface{}, category interface{}) *Repository_AddCategory_Call {
	return &Repository_AddCategory_Call{Call: _e.mock.On("AddCategory", ctx, category)}
}

func (_c *Repository_AddCategory_Call) Run(run func(ctx context.Context, category *models.Category)) *Repository_AddCategory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Category))
	})
	return _c
}

func (_c *Repository_AddCategory_Call) Return(_a0 *models.Category, _a1 error) *Repository_AddCategory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_AddCategory_Call) RunAndReturn(run func(context.Context, *models.Category) (*models.Category, error)) *Repository_AddCategory_Call {
	_c.Call.Return(run)
	return _c
}

// AddFilter provides a mock function with given fields: ctx, filter
func (_m *Repository) AddFilter(ctx context.Context, filter string) (*models.Filter, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for AddFilter")
	}

	var r0 *models.Filter
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.Filter, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.Filter); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Filter)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_AddFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddFilter'
type Repository_AddFilter_Call struct {
	*mock.Call
}

// AddFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - filter string
func (_e *Repository_Expecter) AddFilter(ctx interface{}, filter interface{}) *Repository_AddFilter_Call {
	return &Repository_AddFilter_Call{Call: _e.mock.On("AddFilter", ctx, filter)}
}

func (_c *Repository_AddFilter_Call) Run(run func(ctx context.Context, filter string)) *Repository_AddFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Repository_AddFilter_Call) Return(_a0 *models.Filter, _a1 error) *Repository_AddFilter_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_AddFilter_Call) RunAndReturn(run func(context.Context, string) (*models.Filter, error)) *Repository_AddFilter_Call {
	_c.Call.Return(run)
	return _c
}

// AddPost provides a mock function with given fields: ctx, post
func (_m *Repository) AddPost(ctx context.Context, post *models.Post) (*models.PostResponse, error) {
	ret := _m.Called(ctx, post)

	if len(ret) == 0 {
		panic("no return value specified for AddPost")
	}

	var r0 *models.PostResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Post) (*models.PostResponse, error)); ok {
		return rf(ctx, post)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.Post) *models.PostResponse); ok {
		r0 = rf(ctx, post)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.PostResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.Post) error); ok {
		r1 = rf(ctx, post)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_AddPost_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPost'
type Repository_AddPost_Call struct {
	*mock.Call
}

// AddPost is a helper method to define mock.On call
//   - ctx context.Context
//   - post *models.Post
func (_e *Repository_Expecter) AddPost(ctx interface{}, post interface{}) *Repository_AddPost_Call {
	return &Repository_AddPost_Call{Call: _e.mock.On("AddPost", ctx, post)}
}

func (_c *Repository_AddPost_Call) Run(run func(ctx context.Context, post *models.Post)) *Repository_AddPost_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Post))
	})
	return _c
}

func (_c *Repository_AddPost_Call) Return(_a0 *models.PostResponse, _a1 error) *Repository_AddPost_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_AddPost_Call) RunAndReturn(run func(context.Context, *models.Post) (*models.PostResponse, error)) *Repository_AddPost_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAnalytic provides a mock function with given fields: ctx, id
func (_m *Repository) DeleteAnalytic(ctx context.Context, id int) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAnalytic")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteAnalytic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAnalytic'
type Repository_DeleteAnalytic_Call struct {
	*mock.Call
}

// DeleteAnalytic is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *Repository_Expecter) DeleteAnalytic(ctx interface{}, id interface{}) *Repository_DeleteAnalytic_Call {
	return &Repository_DeleteAnalytic_Call{Call: _e.mock.On("DeleteAnalytic", ctx, id)}
}

func (_c *Repository_DeleteAnalytic_Call) Run(run func(ctx context.Context, id int)) *Repository_DeleteAnalytic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *Repository_DeleteAnalytic_Call) Return(_a0 error) *Repository_DeleteAnalytic_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteAnalytic_Call) RunAndReturn(run func(context.Context, int) error) *Repository_DeleteAnalytic_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCategory provides a mock function with given fields: ctx, category
func (_m *Repository) DeleteCategory(ctx context.Context, category string) error {
	ret := _m.Called(ctx, category)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCategory")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, category)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteCategory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCategory'
type Repository_DeleteCategory_Call struct {
	*mock.Call
}

// DeleteCategory is a helper method to define mock.On call
//   - ctx context.Context
//   - category string
func (_e *Repository_Expecter) DeleteCategory(ctx interface{}, category interface{}) *Repository_DeleteCategory_Call {
	return &Repository_DeleteCategory_Call{Call: _e.mock.On("DeleteCategory", ctx, category)}
}

func (_c *Repository_DeleteCategory_Call) Run(run func(ctx context.Context, category string)) *Repository_DeleteCategory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Repository_DeleteCategory_Call) Return(_a0 error) *Repository_DeleteCategory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteCategory_Call) RunAndReturn(run func(context.Context, string) error) *Repository_DeleteCategory_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteFilter provides a mock function with given fields: ctx, filter
func (_m *Repository) DeleteFilter(ctx context.Context, filter string) error {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFilter")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, filter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFilter'
type Repository_DeleteFilter_Call struct {
	*mock.Call
}

// DeleteFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - filter string
func (_e *Repository_Expecter) DeleteFilter(ctx interface{}, filter interface{}) *Repository_DeleteFilter_Call {
	return &Repository_DeleteFilter_Call{Call: _e.mock.On("DeleteFilter", ctx, filter)}
}

func (_c *Repository_DeleteFilter_Call) Run(run func(ctx context.Context, filter string)) *Repository_DeleteFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Repository_DeleteFilter_Call) Return(_a0 error) *Repository_DeleteFilter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteFilter_Call) RunAndReturn(run func(context.Context, string) error) *Repository_DeleteFilter_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePost provides a mock function with given fields: ctx, id
func (_m *Repository) DeletePost(ctx context.Context, id int) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeletePost")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeletePost_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePost'
type Repository_DeletePost_Call struct {
	*mock.Call
}

// DeletePost is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *Repository_Expecter) DeletePost(ctx interface{}, id interface{}) *Repository_DeletePost_Call {
	return &Repository_DeletePost_Call{Call: _e.mock.On("DeletePost", ctx, id)}
}

func (_c *Repository_DeletePost_Call) Run(run func(ctx context.Context, id int)) *Repository_DeletePost_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *Repository_DeletePost_Call) Return(_a0 error) *Repository_DeletePost_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeletePost_Call) RunAndReturn(run func(context.Context, int) error) *Repository_DeletePost_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllCategories provides a mock function with given fields: ctx
func (_m *Repository) GetAllCategories(ctx context.Context) ([]*models.Category, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllCategories")
	}

	var r0 []*models.Category
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*models.Category, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*models.Category); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Category)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetAllCategories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllCategories'
type Repository_GetAllCategories_Call struct {
	*mock.Call
}

// GetAllCategories is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Repository_Expecter) GetAllCategories(ctx interface{}) *Repository_GetAllCategories_Call {
	return &Repository_GetAllCategories_Call{Call: _e.mock.On("GetAllCategories", ctx)}
}

func (_c *Repository_GetAllCategories_Call) Run(run func(ctx context.Context)) *Repository_GetAllCategories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Repository_GetAllCategories_Call) Return(_a0 []*models.Category, _a1 error) *Repository_GetAllCategories_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetAllCategories_Call) RunAndReturn(run func(context.Context) ([]*models.Category, error)) *Repository_GetAllCategories_Call {
	_c.Call.Return(run)
	return _c
}

// GetAnalytic provides a mock function with given fields: ctx, postID
func (_m *Repository) GetAnalytic(ctx context.Context, postID int) (*models.AnalyticResp, error) {
	ret := _m.Called(ctx, postID)

	if len(ret) == 0 {
		panic("no return value specified for GetAnalytic")
	}

	var r0 *models.AnalyticResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*models.AnalyticResp, error)); ok {
		return rf(ctx, postID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *models.AnalyticResp); ok {
		r0 = rf(ctx, postID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.AnalyticResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, postID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetAnalytic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAnalytic'
type Repository_GetAnalytic_Call struct {
	*mock.Call
}

// GetAnalytic is a helper method to define mock.On call
//   - ctx context.Context
//   - postID int
func (_e *Repository_Expecter) GetAnalytic(ctx interface{}, postID interface{}) *Repository_GetAnalytic_Call {
	return &Repository_GetAnalytic_Call{Call: _e.mock.On("GetAnalytic", ctx, postID)}
}

func (_c *Repository_GetAnalytic_Call) Run(run func(ctx context.Context, postID int)) *Repository_GetAnalytic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *Repository_GetAnalytic_Call) Return(_a0 *models.AnalyticResp, _a1 error) *Repository_GetAnalytic_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetAnalytic_Call) RunAndReturn(run func(context.Context, int) (*models.AnalyticResp, error)) *Repository_GetAnalytic_Call {
	_c.Call.Return(run)
	return _c
}

// GetCategoriesWithPosts provides a mock function with given fields: ctx, public
func (_m *Repository) GetCategoriesWithPosts(ctx context.Context, public bool) (map[string][]*models.PostResponse, error) {
	ret := _m.Called(ctx, public)

	if len(ret) == 0 {
		panic("no return value specified for GetCategoriesWithPosts")
	}

	var r0 map[string][]*models.PostResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, bool) (map[string][]*models.PostResponse, error)); ok {
		return rf(ctx, public)
	}
	if rf, ok := ret.Get(0).(func(context.Context, bool) map[string][]*models.PostResponse); ok {
		r0 = rf(ctx, public)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]*models.PostResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, bool) error); ok {
		r1 = rf(ctx, public)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetCategoriesWithPosts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCategoriesWithPosts'
type Repository_GetCategoriesWithPosts_Call struct {
	*mock.Call
}

// GetCategoriesWithPosts is a helper method to define mock.On call
//   - ctx context.Context
//   - public bool
func (_e *Repository_Expecter) GetCategoriesWithPosts(ctx interface{}, public interface{}) *Repository_GetCategoriesWithPosts_Call {
	return &Repository_GetCategoriesWithPosts_Call{Call: _e.mock.On("GetCategoriesWithPosts", ctx, public)}
}

func (_c *Repository_GetCategoriesWithPosts_Call) Run(run func(ctx context.Context, public bool)) *Repository_GetCategoriesWithPosts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bool))
	})
	return _c
}

func (_c *Repository_GetCategoriesWithPosts_Call) Return(_a0 map[string][]*models.PostResponse, _a1 error) *Repository_GetCategoriesWithPosts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetCategoriesWithPosts_Call) RunAndReturn(run func(context.Context, bool) (map[string][]*models.PostResponse, error)) *Repository_GetCategoriesWithPosts_Call {
	_c.Call.Return(run)
	return _c
}

// GetFilters provides a mock function with given fields: ctx
func (_m *Repository) GetFilters(ctx context.Context) ([]*models.Filter, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetFilters")
	}

	var r0 []*models.Filter
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*models.Filter, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*models.Filter); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Filter)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetFilters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFilters'
type Repository_GetFilters_Call struct {
	*mock.Call
}

// GetFilters is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Repository_Expecter) GetFilters(ctx interface{}) *Repository_GetFilters_Call {
	return &Repository_GetFilters_Call{Call: _e.mock.On("GetFilters", ctx)}
}

func (_c *Repository_GetFilters_Call) Run(run func(ctx context.Context)) *Repository_GetFilters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Repository_GetFilters_Call) Return(_a0 []*models.Filter, _a1 error) *Repository_GetFilters_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetFilters_Call) RunAndReturn(run func(context.Context) ([]*models.Filter, error)) *Repository_GetFilters_Call {
	_c.Call.Return(run)
	return _c
}

// GetFiltersCount provides a mock function with given fields: ctx
func (_m *Repository) GetFiltersCount(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetFiltersCount")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetFiltersCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFiltersCount'
type Repository_GetFiltersCount_Call struct {
	*mock.Call
}

// GetFiltersCount is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Repository_Expecter) GetFiltersCount(ctx interface{}) *Repository_GetFiltersCount_Call {
	return &Repository_GetFiltersCount_Call{Call: _e.mock.On("GetFiltersCount", ctx)}
}

func (_c *Repository_GetFiltersCount_Call) Run(run func(ctx context.Context)) *Repository_GetFiltersCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Repository_GetFiltersCount_Call) Return(_a0 int, _a1 error) *Repository_GetFiltersCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetFiltersCount_Call) RunAndReturn(run func(context.Context) (int, error)) *Repository_GetFiltersCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetFiltersWithPagination provides a mock function with given fields: ctx, limit, offset
func (_m *Repository) GetFiltersWithPagination(ctx context.Context, limit int, offset int) ([]*models.Filter, error) {
	ret := _m.Called(ctx, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for GetFiltersWithPagination")
	}

	var r0 []*models.Filter
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) ([]*models.Filter, error)); ok {
		return rf(ctx, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) []*models.Filter); ok {
		r0 = rf(ctx, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Filter)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) error); ok {
		r1 = rf(ctx, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetFiltersWithPagination_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFiltersWithPagination'
type Repository_GetFiltersWithPagination_Call struct {
	*mock.Call
}

// GetFiltersWithPagination is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
//   - offset int
func (_e *Repository_Expecter) GetFiltersWithPagination(ctx interface{}, limit interface{}, offset interface{}) *Repository_GetFiltersWithPagination_Call {
	return &Repository_GetFiltersWithPagination_Call{Call: _e.mock.On("GetFiltersWithPagination", ctx, limit, offset)}
}

func (_c *Repository_GetFiltersWithPagination_Call) Run(run func(ctx context.Context, limit int, offset int)) *Repository_GetFiltersWithPagination_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *Repository_GetFiltersWithPagination_Call) Return(_a0 []*models.Filter, _a1 error) *Repository_GetFiltersWithPagination_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetFiltersWithPagination_Call) RunAndReturn(run func(context.Context, int, int) ([]*models.Filter, error)) *Repository_GetFiltersWithPagination_Call {
	_c.Call.Return(run)
	return _c
}

// GetPostIDByAnalytic provides a mock function with given fields: ctx, id
func (_m *Repository) GetPostIDByAnalytic(ctx context.Context, id int) (int, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetPostIDByAnalytic")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (int, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) int); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetPostIDByAnalytic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPostIDByAnalytic'
type Repository_GetPostIDByAnalytic_Call struct {
	*mock.Call
}

// GetPostIDByAnalytic is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *Repository_Expecter) GetPostIDByAnalytic(ctx interface{}, id interface{}) *Repository_GetPostIDByAnalytic_Call {
	return &Repository_GetPostIDByAnalytic_Call{Call: _e.mock.On("GetPostIDByAnalytic", ctx, id)}
}

func (_c *Repository_GetPostIDByAnalytic_Call) Run(run func(ctx context.Context, id int)) *Repository_GetPostIDByAnalytic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *Repository_GetPostIDByAnalytic_Call) Return(_a0 int, _a1 error) *Repository_GetPostIDByAnalytic_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetPostIDByAnalytic_Call) RunAndReturn(run func(context.Context, int) (int, error)) *Repository_GetPostIDByAnalytic_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAnalytic provides a mock function with given fields: ctx, id, analytics
func (_m *Repository) UpdateAnalytic(ctx context.Context, id int, analytics *models.AnalyticUpdate) (*models.Analytic, error) {
	ret := _m.Called(ctx, id, analytics)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAnalytic")
	}

	var r0 *models.Analytic
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, *models.AnalyticUpdate) (*models.Analytic, error)); ok {
		return rf(ctx, id, analytics)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, *models.AnalyticUpdate) *models.Analytic); ok {
		r0 = rf(ctx, id, analytics)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Analytic)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, *models.AnalyticUpdate) error); ok {
		r1 = rf(ctx, id, analytics)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_UpdateAnalytic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAnalytic'
type Repository_UpdateAnalytic_Call struct {
	*mock.Call
}

// UpdateAnalytic is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - analytics *models.AnalyticUpdate
func (_e *Repository_Expecter) UpdateAnalytic(ctx interface{}, id interface{}, analytics interface{}) *Repository_UpdateAnalytic_Call {
	return &Repository_UpdateAnalytic_Call{Call: _e.mock.On("UpdateAnalytic", ctx, id, analytics)}
}

func (_c *Repository_UpdateAnalytic_Call) Run(run func(ctx context.Context, id int, analytics *models.AnalyticUpdate)) *Repository_UpdateAnalytic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(*models.AnalyticUpdate))
	})
	return _c
}

func (_c *Repository_UpdateAnalytic_Call) Return(_a0 *models.Analytic, _a1 error) *Repository_UpdateAnalytic_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_UpdateAnalytic_Call) RunAndReturn(run func(context.Context, int, *models.AnalyticUpdate) (*models.Analytic, error)) *Repository_UpdateAnalytic_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCategory provides a mock function with given fields: ctx, category, title
func (_m *Repository) UpdateCategory(ctx context.Context, category string, title string) (*models.Category, error) {
	ret := _m.Called(ctx, category, title)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCategory")
	}

	var r0 *models.Category
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*models.Category, error)); ok {
		return rf(ctx, category, title)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *models.Category); ok {
		r0 = rf(ctx, category, title)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Category)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, category, title)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_UpdateCategory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCategory'
type Repository_UpdateCategory_Call struct {
	*mock.Call
}

// UpdateCategory is a helper method to define mock.On call
//   - ctx context.Context
//   - category string
//   - title string
func (_e *Repository_Expecter) UpdateCategory(ctx interface{}, category interface{}, title interface{}) *Repository_UpdateCategory_Call {
	return &Repository_UpdateCategory_Call{Call: _e.mock.On("UpdateCategory", ctx, category, title)}
}

func (_c *Repository_UpdateCategory_Call) Run(run func(ctx context.Context, category string, title string)) *Repository_UpdateCategory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Repository_UpdateCategory_Call) Return(_a0 *models.Category, _a1 error) *Repository_UpdateCategory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_UpdateCategory_Call) RunAndReturn(run func(context.Context, string, string) (*models.Category, error)) *Repository_UpdateCategory_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePost provides a mock function with given fields: ctx, id, post
func (_m *Repository) UpdatePost(ctx context.Context, id int, post *models.PostUpdate) (*models.PostResponse, error) {
	ret := _m.Called(ctx, id, post)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePost")
	}

	var r0 *models.PostResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, *models.PostUpdate) (*models.PostResponse, error)); ok {
		return rf(ctx, id, post)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, *models.PostUpdate) *models.PostResponse); ok {
		r0 = rf(ctx, id, post)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.PostResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, *models.PostUpdate) error); ok {
		r1 = rf(ctx, id, post)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_UpdatePost_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePost'
type Repository_UpdatePost_Call struct {
	*mock.Call
}

// UpdatePost is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - post *models.PostUpdate
func (_e *Repository_Expecter) UpdatePost(ctx interface{}, id interface{}, post interface{}) *Repository_UpdatePost_Call {
	return &Repository_UpdatePost_Call{Call: _e.mock.On("UpdatePost", ctx, id, post)}
}

func (_c *Repository_UpdatePost_Call) Run(run func(ctx context.Context, id int, post *models.PostUpdate)) *Repository_UpdatePost_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(*models.PostUpdate))
	})
	return _c
}

func (_c *Repository_UpdatePost_Call) Return(_a0 *models.PostResponse, _a1 error) *Repository_UpdatePost_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_UpdatePost_Call) RunAndReturn(run func(context.Context, int, *models.PostUpdate) (*models.PostResponse, error)) *Repository_UpdatePost_Call {
	_c.Call.Return(run)
	return _c
}

// NewRepository creates a new instance of Repository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *Repository {
	mock := &Repository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
